# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
Module containing base I/O image funcionalities.  They correspond directly to the MIALib C function wrapped to python thanks to SWIG.  This is an initial test module for the JIPL (Joint Image Processing Library) developed in the framework of the JEODPP of the EO&SS@BD pilot project.
Contact: Pierre.Soille@jrc.ec.europa.eu
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_io_base', [dirname(__file__)])
        except ImportError:
            import _io_base
            return _io_base
        if fp is not None:
            try:
                _mod = imp.load_module('_io_base', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _io_base = swig_import_helper()
    del swig_import_helper
else:
    import _io_base
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


ADD_op = _io_base.ADD_op
SUB_op = _io_base.SUB_op
MULT_op = _io_base.MULT_op
DIV_op = _io_base.DIV_op
INF_op = _io_base.INF_op
SUP_op = _io_base.SUP_op
MASK_op = _io_base.MASK_op
ADD_op_ovfl = _io_base.ADD_op_ovfl
SUB_op_ovfl = _io_base.SUB_op_ovfl
MULT_op_ovfl = _io_base.MULT_op_ovfl
AND_op = _io_base.AND_op
OR_op = _io_base.OR_op
XOR_op = _io_base.XOR_op
CMP_op = _io_base.CMP_op
ABSSUB_op = _io_base.ABSSUB_op
MASK_op2 = _io_base.MASK_op2
SUBSWAP_op = _io_base.SUBSWAP_op
SUBSWAP_op_ovfl = _io_base.SUBSWAP_op_ovfl
EQUAL_op = _io_base.EQUAL_op
OVW_op = _io_base.OVW_op
POW_op = _io_base.POW_op
NDI_op = _io_base.NDI_op
SUBSWAPCST_op = _io_base.SUBSWAPCST_op
FirstBitOn_op = _io_base.FirstBitOn_op
NAND_op = _io_base.NAND_op
ATAN_op = _io_base.ATAN_op
COS_op = _io_base.COS_op
SIN_op = _io_base.SIN_op
_MIATYPES_H = _io_base._MIATYPES_H
class G_TYPE(_object):
    """
    C++ includes: miatypes.h

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, G_TYPE, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, G_TYPE, name)
    __repr__ = _swig_repr
    __swig_setmethods__["generic_val"] = _io_base.G_TYPE_generic_val_set
    __swig_getmethods__["generic_val"] = _io_base.G_TYPE_generic_val_get
    if _newclass:generic_val = _swig_property(_io_base.G_TYPE_generic_val_get, _io_base.G_TYPE_generic_val_set)
    __swig_setmethods__["uc_val"] = _io_base.G_TYPE_uc_val_set
    __swig_getmethods__["uc_val"] = _io_base.G_TYPE_uc_val_get
    if _newclass:uc_val = _swig_property(_io_base.G_TYPE_uc_val_get, _io_base.G_TYPE_uc_val_set)
    __swig_setmethods__["us_val"] = _io_base.G_TYPE_us_val_set
    __swig_getmethods__["us_val"] = _io_base.G_TYPE_us_val_get
    if _newclass:us_val = _swig_property(_io_base.G_TYPE_us_val_get, _io_base.G_TYPE_us_val_set)
    __swig_setmethods__["s_val"] = _io_base.G_TYPE_s_val_set
    __swig_getmethods__["s_val"] = _io_base.G_TYPE_s_val_get
    if _newclass:s_val = _swig_property(_io_base.G_TYPE_s_val_get, _io_base.G_TYPE_s_val_set)
    __swig_setmethods__["u32_val"] = _io_base.G_TYPE_u32_val_set
    __swig_getmethods__["u32_val"] = _io_base.G_TYPE_u32_val_get
    if _newclass:u32_val = _swig_property(_io_base.G_TYPE_u32_val_get, _io_base.G_TYPE_u32_val_set)
    __swig_setmethods__["i32_val"] = _io_base.G_TYPE_i32_val_set
    __swig_getmethods__["i32_val"] = _io_base.G_TYPE_i32_val_get
    if _newclass:i32_val = _swig_property(_io_base.G_TYPE_i32_val_get, _io_base.G_TYPE_i32_val_set)
    __swig_setmethods__["u64_val"] = _io_base.G_TYPE_u64_val_set
    __swig_getmethods__["u64_val"] = _io_base.G_TYPE_u64_val_get
    if _newclass:u64_val = _swig_property(_io_base.G_TYPE_u64_val_get, _io_base.G_TYPE_u64_val_set)
    __swig_setmethods__["i64_val"] = _io_base.G_TYPE_i64_val_set
    __swig_getmethods__["i64_val"] = _io_base.G_TYPE_i64_val_get
    if _newclass:i64_val = _swig_property(_io_base.G_TYPE_i64_val_get, _io_base.G_TYPE_i64_val_set)
    __swig_setmethods__["f_val"] = _io_base.G_TYPE_f_val_set
    __swig_getmethods__["f_val"] = _io_base.G_TYPE_f_val_get
    if _newclass:f_val = _swig_property(_io_base.G_TYPE_f_val_get, _io_base.G_TYPE_f_val_set)
    __swig_setmethods__["d_val"] = _io_base.G_TYPE_d_val_set
    __swig_getmethods__["d_val"] = _io_base.G_TYPE_d_val_get
    if _newclass:d_val = _swig_property(_io_base.G_TYPE_d_val_get, _io_base.G_TYPE_d_val_set)
    def __init__(self): 
        """
        __init__(G_TYPE self) -> G_TYPE

        C++ includes: miatypes.h

        """
        this = _io_base.new_G_TYPE()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _io_base.delete_G_TYPE
    __del__ = lambda self : None;
G_TYPE_swigregister = _io_base.G_TYPE_swigregister
G_TYPE_swigregister(G_TYPE)

class IMAGE(_object):
    """
    C++ includes: miatypes.h

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IMAGE, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IMAGE, name)
    __repr__ = _swig_repr
    __swig_setmethods__["p_im"] = _io_base.IMAGE_p_im_set
    __swig_getmethods__["p_im"] = _io_base.IMAGE_p_im_get
    if _newclass:p_im = _swig_property(_io_base.IMAGE_p_im_get, _io_base.IMAGE_p_im_set)
    __swig_setmethods__["DataType"] = _io_base.IMAGE_DataType_set
    __swig_getmethods__["DataType"] = _io_base.IMAGE_DataType_get
    if _newclass:DataType = _swig_property(_io_base.IMAGE_DataType_get, _io_base.IMAGE_DataType_set)
    __swig_setmethods__["nx"] = _io_base.IMAGE_nx_set
    __swig_getmethods__["nx"] = _io_base.IMAGE_nx_get
    if _newclass:nx = _swig_property(_io_base.IMAGE_nx_get, _io_base.IMAGE_nx_set)
    __swig_setmethods__["ny"] = _io_base.IMAGE_ny_set
    __swig_getmethods__["ny"] = _io_base.IMAGE_ny_get
    if _newclass:ny = _swig_property(_io_base.IMAGE_ny_get, _io_base.IMAGE_ny_set)
    __swig_setmethods__["nz"] = _io_base.IMAGE_nz_set
    __swig_getmethods__["nz"] = _io_base.IMAGE_nz_get
    if _newclass:nz = _swig_property(_io_base.IMAGE_nz_get, _io_base.IMAGE_nz_set)
    __swig_setmethods__["NByte"] = _io_base.IMAGE_NByte_set
    __swig_getmethods__["NByte"] = _io_base.IMAGE_NByte_get
    if _newclass:NByte = _swig_property(_io_base.IMAGE_NByte_get, _io_base.IMAGE_NByte_set)
    __swig_setmethods__["vol"] = _io_base.IMAGE_vol_set
    __swig_getmethods__["vol"] = _io_base.IMAGE_vol_get
    if _newclass:vol = _swig_property(_io_base.IMAGE_vol_get, _io_base.IMAGE_vol_set)
    __swig_setmethods__["lut"] = _io_base.IMAGE_lut_set
    __swig_getmethods__["lut"] = _io_base.IMAGE_lut_get
    if _newclass:lut = _swig_property(_io_base.IMAGE_lut_get, _io_base.IMAGE_lut_set)
    __swig_setmethods__["g"] = _io_base.IMAGE_g_set
    __swig_getmethods__["g"] = _io_base.IMAGE_g_get
    if _newclass:g = _swig_property(_io_base.IMAGE_g_get, _io_base.IMAGE_g_set)
    def __init__(self, *args): 
        """
        __init__(IMAGE self, int type, long nx, int ny, int nz) -> IMAGE

        C++ includes: miatypes.h

        """
        this = _io_base.new_IMAGE(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _io_base.delete_IMAGE
    __del__ = lambda self : None;
    def iminfoMethod(self):
        """iminfoMethod(IMAGE self)"""
        return _io_base.IMAGE_iminfoMethod(self)

IMAGE_swigregister = _io_base.IMAGE_swigregister
IMAGE_swigregister(IMAGE)

class IMBLOB(_object):
    """
    C++ includes: miatypes.h

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IMBLOB, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IMBLOB, name)
    __repr__ = _swig_repr
    __swig_setmethods__["area"] = _io_base.IMBLOB_area_set
    __swig_getmethods__["area"] = _io_base.IMBLOB_area_get
    if _newclass:area = _swig_property(_io_base.IMBLOB_area_get, _io_base.IMBLOB_area_set)
    __swig_setmethods__["m00"] = _io_base.IMBLOB_m00_set
    __swig_getmethods__["m00"] = _io_base.IMBLOB_m00_get
    if _newclass:m00 = _swig_property(_io_base.IMBLOB_m00_get, _io_base.IMBLOB_m00_set)
    __swig_setmethods__["m10"] = _io_base.IMBLOB_m10_set
    __swig_getmethods__["m10"] = _io_base.IMBLOB_m10_get
    if _newclass:m10 = _swig_property(_io_base.IMBLOB_m10_get, _io_base.IMBLOB_m10_set)
    __swig_setmethods__["m01"] = _io_base.IMBLOB_m01_set
    __swig_getmethods__["m01"] = _io_base.IMBLOB_m01_get
    if _newclass:m01 = _swig_property(_io_base.IMBLOB_m01_get, _io_base.IMBLOB_m01_set)
    __swig_setmethods__["minor"] = _io_base.IMBLOB_minor_set
    __swig_getmethods__["minor"] = _io_base.IMBLOB_minor_get
    if _newclass:minor = _swig_property(_io_base.IMBLOB_minor_get, _io_base.IMBLOB_minor_set)
    __swig_setmethods__["major"] = _io_base.IMBLOB_major_set
    __swig_getmethods__["major"] = _io_base.IMBLOB_major_get
    if _newclass:major = _swig_property(_io_base.IMBLOB_major_get, _io_base.IMBLOB_major_set)
    __swig_setmethods__["irradiance"] = _io_base.IMBLOB_irradiance_set
    __swig_getmethods__["irradiance"] = _io_base.IMBLOB_irradiance_get
    if _newclass:irradiance = _swig_property(_io_base.IMBLOB_irradiance_get, _io_base.IMBLOB_irradiance_set)
    __swig_setmethods__["xcg"] = _io_base.IMBLOB_xcg_set
    __swig_getmethods__["xcg"] = _io_base.IMBLOB_xcg_get
    if _newclass:xcg = _swig_property(_io_base.IMBLOB_xcg_get, _io_base.IMBLOB_xcg_set)
    __swig_setmethods__["ycg"] = _io_base.IMBLOB_ycg_set
    __swig_getmethods__["ycg"] = _io_base.IMBLOB_ycg_get
    if _newclass:ycg = _swig_property(_io_base.IMBLOB_ycg_get, _io_base.IMBLOB_ycg_set)
    __swig_setmethods__["mu11"] = _io_base.IMBLOB_mu11_set
    __swig_getmethods__["mu11"] = _io_base.IMBLOB_mu11_get
    if _newclass:mu11 = _swig_property(_io_base.IMBLOB_mu11_get, _io_base.IMBLOB_mu11_set)
    __swig_setmethods__["mu20"] = _io_base.IMBLOB_mu20_set
    __swig_getmethods__["mu20"] = _io_base.IMBLOB_mu20_get
    if _newclass:mu20 = _swig_property(_io_base.IMBLOB_mu20_get, _io_base.IMBLOB_mu20_set)
    __swig_setmethods__["mu02"] = _io_base.IMBLOB_mu02_set
    __swig_getmethods__["mu02"] = _io_base.IMBLOB_mu02_get
    if _newclass:mu02 = _swig_property(_io_base.IMBLOB_mu02_get, _io_base.IMBLOB_mu02_set)
    __swig_setmethods__["ratio"] = _io_base.IMBLOB_ratio_set
    __swig_getmethods__["ratio"] = _io_base.IMBLOB_ratio_get
    if _newclass:ratio = _swig_property(_io_base.IMBLOB_ratio_get, _io_base.IMBLOB_ratio_set)
    __swig_setmethods__["dir"] = _io_base.IMBLOB_dir_set
    __swig_getmethods__["dir"] = _io_base.IMBLOB_dir_get
    if _newclass:dir = _swig_property(_io_base.IMBLOB_dir_get, _io_base.IMBLOB_dir_set)
    __swig_setmethods__["r"] = _io_base.IMBLOB_r_set
    __swig_getmethods__["r"] = _io_base.IMBLOB_r_get
    if _newclass:r = _swig_property(_io_base.IMBLOB_r_get, _io_base.IMBLOB_r_set)
    def __init__(self): 
        """
        __init__(IMBLOB self) -> IMBLOB

        C++ includes: miatypes.h

        """
        this = _io_base.new_IMBLOB()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _io_base.delete_IMBLOB
    __del__ = lambda self : None;
IMBLOB_swigregister = _io_base.IMBLOB_swigregister
IMBLOB_swigregister(IMBLOB)

_MIALIB_IO_H = _io_base._MIALIB_IO_H

def GDAL2MIALDataType(*args):
  """
    GDAL2MIALDataType(int aGDALDataType) -> int

    par: Synopsis:
        Data type conversion from gdal to mial  

    Parameters
    ----------
    * `aGDALDataType` :  
        integer for gdal data type  

    Returns
    -------
    integer with mial data type matching the input gdal data type  

    par: Creation date:
        20130911  

    """
  return _io_base.GDAL2MIALDataType(*args)

def GDALInfoJIP(*args):
  """
    GDALInfoJIP(char * imfn) -> IMAGE

    The values are in the following order: x-coordinate of upper left corner of
    upper left pixel, W-E pixel resolution, rotation (0 if image is north up),
    x-coordinate of upper left corner of upper left pixel, rotation (0 if image is
    north up), N-S pixel resolution, number of rows of raster, number of columns of
    raster, number of bands of raster, and EPSG code of projection (-1 if it could
    not be retrieved). The function also prints in stdout the type of driver used
    for reading fn and the name of the projection.  

    Parameters
    ----------
    * `imfn` :  
        string for image file name  

    Returns
    -------
    an image of type t_DOUBLE holding 10 values regarding the geolocation and size
    of the image, NIL otherwise  

    """
  return _io_base.GDALInfoJIP(*args)

def GDALRead(*args):
  """
    GDALRead(char * imfn, int band, int nXOff, int nYOff, int nXSize, int nYSize, int nBufXSize, 
        int nBufYSize) -> IMAGE

    par: Synopsis:
        read a single band of a raster image using drivers installed in gdal library  

    Parameters
    ----------
    * `fn` :  
        a string for the name of an image file (possibly including its path)  
    * `band` :  
        an integer for the band number, 0 for first band  
    * `nXOff` :  
        The pixel offset to the top left corner of the region of the band to be
        accessed. This would be zero to start from the left side (default value).  
    * `nYOff` :  
        The line offset to the top left corner of the region of the band to be
        accessed. This would be zero to start from the top (default value).  
    * `nXSize` :  
        The width of the region of the band to be accessed in pixels.  
    * `nYSize` :  
        The height of the region of the band to be accessed in lines.  
    * `nBufXSize` :  
        integer for number of columns of output image (default is nXSize).  
    * `nBufYSize` :  
        integer for number of lines of output image (default is nYSize)  

    par: Description:
        read a given band of a raster image using gdal with the specified options.
        Any invalid geometry parameter will result in the whole image domain to be
        read!  

    """
  return _io_base.GDALRead(*args)

def read_all(*args):
  """
    read_all(char * fn, int nx, int ny, int nz, int data_type, int header_size, int pc) -> IMAGE

    """
  return _io_base.read_all(*args)

def read_image(*args):
  """
    read_image(char * fn) -> IMAGE

    """
  return _io_base.read_image(*args)

def read_image_to_type(*args):
  """
    read_image_to_type(char * fn, int data_type) -> IMAGE

    """
  return _io_base.read_image_to_type(*args)

def read_image_data(*args):
  """
    read_image_data(FILE * fp, IMAGE im, int pc) -> ERROR_TYPE

    """
  return _io_base.read_image_data(*args)

def write_image_data(*args):
  """
    write_image_data(FILE * fp, IMAGE im, int pc) -> ERROR_TYPE

    """
  return _io_base.write_image_data(*args)

def write_ColorMap_tiff(*args):
  """
    write_ColorMap_tiff(IMAGE im, char * fn) -> ERROR_TYPE

    """
  return _io_base.write_ColorMap_tiff(*args)

def write_tiff(*args):
  """
    write_tiff(IMAGE im, char * fn) -> ERROR_TYPE

    """
  return _io_base.write_tiff(*args)

def writeTiffOneStripPerLine(*args):
  """
    writeTiffOneStripPerLine(IMAGE im, char * fn, char * desc) -> ERROR_TYPE

    """
  return _io_base.writeTiffOneStripPerLine(*args)

def GetGeoKey(*args):
  """
    GetGeoKey(char * fname, char * keyname) -> IMAGE

    """
  return _io_base.GetGeoKey(*args)

def GetTIFFTagGeo(*args):
  """
    GetTIFFTagGeo(char * fn, char * tagname) -> IMAGE

    """
  return _io_base.GetTIFFTagGeo(*args)

def read_image2(*args):
  """
    read_image2(char * fn, int x, int y, int szx, int szy, int scale) -> IMAGE

    """
  return _io_base.read_image2(*args)

def readTiffSubset(*args):
  """
    readTiffSubset(char * fn, int x, int y, unsigned int szx, unsigned int szy) -> IMAGE

    """
  return _io_base.readTiffSubset(*args)

def tiffinfo(*args):
  """
    tiffinfo(char * fn, char * field, float * val) -> ERROR_TYPE

    par: Synopsis:
        tiffinfo fn field val  

    Parameters
    ----------
    * `fn` :  
        a string for the name of a TIFF file (possibly including its path)  
    * `field` :  
        a string for the TIFF field name  
    * `val` :  
        holding the value of the specified field  

    par: Description:
        the following field names are valid: TIFFTAG_IMAGEWIDTH,
        TIFFTAG_IMAGELENGTH, TIFFTAG_BITSPERSAMPLE, TIFFTAG_SAMPLESPERPIXEL,
        TIFFTAG_SAMPLEFORMAT (1 for unsigned integer data, 2 for two's complement
        signed integer data, and 3 for floating point data), GTModelTypeGeoKey (1
        for projected, 2 for geographic, and 3 for geocentric),
        GeographicTypeGeoKey, ProjectedCSTypeGeoKey, and GTRasterTypeGeoKey (1 for
        RasterPixelIsArea).  

    """
  return _io_base.tiffinfo(*args)

def tiffinfoJIP(*args):
  """
    tiffinfoJIP(char * fn) -> IMAGE

    par: Synopsis:
        tiffinfoJIP fn field val  

    Parameters
    ----------
    * `fn` :  
        a string for the name of a TIFF file (possibly including its path)  

        *  

    Returns
    -------
    an image holding the values of the fields values in the indicated order  

    par: Description:
        the following sequence of values are inserted in the image:
        TIFFTAG_IMAGEWIDTH, TIFFTAG_IMAGELENGTH, TIFFTAG_BITSPERSAMPLE,
        TIFFTAG_SAMPLESPERPIXEL, TIFFTAG_SAMPLEFORMAT (1 for unsigned integer data,
        2 for two's complement signed integer data, and 3 for floating point data),
        GTModelTypeGeoKey (1 for projected, 2 for geographic, and 3 for geocentric),
        GeographicTypeGeoKey, ProjectedCSTypeGeoKey, and GTRasterTypeGeoKey (1 for
        RasterPixelIsArea).  

    """
  return _io_base.tiffinfoJIP(*args)

def read_image_data2(*args):
  """
    read_image_data2(FILE * fp, IMAGE im, int x, int y, int inx, int scale) -> ERROR_TYPE

    """
  return _io_base.read_image_data2(*args)

def writeGeoTiffOneStripPerLine(*args):
  """
    writeGeoTiffOneStripPerLine(IMAGE im, char * fn, int PCSCode, double xoff, double yoff, double scale, unsigned short RasterType, 
        int nodata_flag, int nodata_val, int metadata_flag, char * metadata_str) -> ERROR_TYPE

    """
  return _io_base.writeGeoTiffOneStripPerLine(*args)

def writeMBGeoTiffOneStripPerLine(*args):
  """
    writeMBGeoTiffOneStripPerLine(IMAGE ** imap, char * fn, int PCSCode, double xoff, double yoff, double scale, unsigned short RasterType, 
        int nodata_flag, int nodata_val, int metadata_flag, 
        char * metadata_str) -> ERROR_TYPE

    """
  return _io_base.writeMBGeoTiffOneStripPerLine(*args)

def print_mia_banner():
  """
    print_mia_banner()

    """
  return _io_base.print_mia_banner()
# This file is compatible with both classic and new-style classes.


