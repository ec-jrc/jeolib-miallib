# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
Module containing base imem image funcionalities.  They correspond directly to the MIALib C function wrapped to python thanks to SWIG.  This is an initial test module for the JIPL (Joint Image Processing Library) developed in the framework of the JEODPP of the EO&SS@BD pilot project.
Contact: Pierre.Soille@jrc.ec.europa.eu
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_imem_base', [dirname(__file__)])
        except ImportError:
            import _imem_base
            return _imem_base
        if fp is not None:
            try:
                _mod = imp.load_module('_imem_base', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _imem_base = swig_import_helper()
    del swig_import_helper
else:
    import _imem_base
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


_MIATYPES_H = _imem_base._MIATYPES_H
class G_TYPE(_object):
    """
    C++ includes: miatypes.h

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, G_TYPE, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, G_TYPE, name)
    __repr__ = _swig_repr
    __swig_setmethods__["generic_val"] = _imem_base.G_TYPE_generic_val_set
    __swig_getmethods__["generic_val"] = _imem_base.G_TYPE_generic_val_get
    if _newclass:generic_val = _swig_property(_imem_base.G_TYPE_generic_val_get, _imem_base.G_TYPE_generic_val_set)
    __swig_setmethods__["uc_val"] = _imem_base.G_TYPE_uc_val_set
    __swig_getmethods__["uc_val"] = _imem_base.G_TYPE_uc_val_get
    if _newclass:uc_val = _swig_property(_imem_base.G_TYPE_uc_val_get, _imem_base.G_TYPE_uc_val_set)
    __swig_setmethods__["us_val"] = _imem_base.G_TYPE_us_val_set
    __swig_getmethods__["us_val"] = _imem_base.G_TYPE_us_val_get
    if _newclass:us_val = _swig_property(_imem_base.G_TYPE_us_val_get, _imem_base.G_TYPE_us_val_set)
    __swig_setmethods__["s_val"] = _imem_base.G_TYPE_s_val_set
    __swig_getmethods__["s_val"] = _imem_base.G_TYPE_s_val_get
    if _newclass:s_val = _swig_property(_imem_base.G_TYPE_s_val_get, _imem_base.G_TYPE_s_val_set)
    __swig_setmethods__["u32_val"] = _imem_base.G_TYPE_u32_val_set
    __swig_getmethods__["u32_val"] = _imem_base.G_TYPE_u32_val_get
    if _newclass:u32_val = _swig_property(_imem_base.G_TYPE_u32_val_get, _imem_base.G_TYPE_u32_val_set)
    __swig_setmethods__["i32_val"] = _imem_base.G_TYPE_i32_val_set
    __swig_getmethods__["i32_val"] = _imem_base.G_TYPE_i32_val_get
    if _newclass:i32_val = _swig_property(_imem_base.G_TYPE_i32_val_get, _imem_base.G_TYPE_i32_val_set)
    __swig_setmethods__["u64_val"] = _imem_base.G_TYPE_u64_val_set
    __swig_getmethods__["u64_val"] = _imem_base.G_TYPE_u64_val_get
    if _newclass:u64_val = _swig_property(_imem_base.G_TYPE_u64_val_get, _imem_base.G_TYPE_u64_val_set)
    __swig_setmethods__["i64_val"] = _imem_base.G_TYPE_i64_val_set
    __swig_getmethods__["i64_val"] = _imem_base.G_TYPE_i64_val_get
    if _newclass:i64_val = _swig_property(_imem_base.G_TYPE_i64_val_get, _imem_base.G_TYPE_i64_val_set)
    __swig_setmethods__["f_val"] = _imem_base.G_TYPE_f_val_set
    __swig_getmethods__["f_val"] = _imem_base.G_TYPE_f_val_get
    if _newclass:f_val = _swig_property(_imem_base.G_TYPE_f_val_get, _imem_base.G_TYPE_f_val_set)
    __swig_setmethods__["d_val"] = _imem_base.G_TYPE_d_val_set
    __swig_getmethods__["d_val"] = _imem_base.G_TYPE_d_val_get
    if _newclass:d_val = _swig_property(_imem_base.G_TYPE_d_val_get, _imem_base.G_TYPE_d_val_set)
    def __init__(self): 
        """
        __init__(G_TYPE self) -> G_TYPE

        C++ includes: miatypes.h

        """
        this = _imem_base.new_G_TYPE()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _imem_base.delete_G_TYPE
    __del__ = lambda self : None;
G_TYPE_swigregister = _imem_base.G_TYPE_swigregister
G_TYPE_swigregister(G_TYPE)

class IMAGE(_object):
    """
    C++ includes: miatypes.h

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IMAGE, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IMAGE, name)
    __repr__ = _swig_repr
    __swig_setmethods__["p_im"] = _imem_base.IMAGE_p_im_set
    __swig_getmethods__["p_im"] = _imem_base.IMAGE_p_im_get
    if _newclass:p_im = _swig_property(_imem_base.IMAGE_p_im_get, _imem_base.IMAGE_p_im_set)
    __swig_setmethods__["DataType"] = _imem_base.IMAGE_DataType_set
    __swig_getmethods__["DataType"] = _imem_base.IMAGE_DataType_get
    if _newclass:DataType = _swig_property(_imem_base.IMAGE_DataType_get, _imem_base.IMAGE_DataType_set)
    __swig_setmethods__["nx"] = _imem_base.IMAGE_nx_set
    __swig_getmethods__["nx"] = _imem_base.IMAGE_nx_get
    if _newclass:nx = _swig_property(_imem_base.IMAGE_nx_get, _imem_base.IMAGE_nx_set)
    __swig_setmethods__["ny"] = _imem_base.IMAGE_ny_set
    __swig_getmethods__["ny"] = _imem_base.IMAGE_ny_get
    if _newclass:ny = _swig_property(_imem_base.IMAGE_ny_get, _imem_base.IMAGE_ny_set)
    __swig_setmethods__["nz"] = _imem_base.IMAGE_nz_set
    __swig_getmethods__["nz"] = _imem_base.IMAGE_nz_get
    if _newclass:nz = _swig_property(_imem_base.IMAGE_nz_get, _imem_base.IMAGE_nz_set)
    __swig_setmethods__["NByte"] = _imem_base.IMAGE_NByte_set
    __swig_getmethods__["NByte"] = _imem_base.IMAGE_NByte_get
    if _newclass:NByte = _swig_property(_imem_base.IMAGE_NByte_get, _imem_base.IMAGE_NByte_set)
    __swig_setmethods__["vol"] = _imem_base.IMAGE_vol_set
    __swig_getmethods__["vol"] = _imem_base.IMAGE_vol_get
    if _newclass:vol = _swig_property(_imem_base.IMAGE_vol_get, _imem_base.IMAGE_vol_set)
    __swig_setmethods__["lut"] = _imem_base.IMAGE_lut_set
    __swig_getmethods__["lut"] = _imem_base.IMAGE_lut_get
    if _newclass:lut = _swig_property(_imem_base.IMAGE_lut_get, _imem_base.IMAGE_lut_set)
    __swig_setmethods__["g"] = _imem_base.IMAGE_g_set
    __swig_getmethods__["g"] = _imem_base.IMAGE_g_get
    if _newclass:g = _swig_property(_imem_base.IMAGE_g_get, _imem_base.IMAGE_g_set)
    def __init__(self, *args): 
        """
        __init__(IMAGE self, int type, long nx, int ny, int nz) -> IMAGE

        C++ includes: miatypes.h

        """
        this = _imem_base.new_IMAGE(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _imem_base.delete_IMAGE
    __del__ = lambda self : None;
    def iminfoMethod(self):
        """iminfoMethod(IMAGE self)"""
        return _imem_base.IMAGE_iminfoMethod(self)

IMAGE_swigregister = _imem_base.IMAGE_swigregister
IMAGE_swigregister(IMAGE)

class IMBLOB(_object):
    """
    C++ includes: miatypes.h

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IMBLOB, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IMBLOB, name)
    __repr__ = _swig_repr
    __swig_setmethods__["area"] = _imem_base.IMBLOB_area_set
    __swig_getmethods__["area"] = _imem_base.IMBLOB_area_get
    if _newclass:area = _swig_property(_imem_base.IMBLOB_area_get, _imem_base.IMBLOB_area_set)
    __swig_setmethods__["m00"] = _imem_base.IMBLOB_m00_set
    __swig_getmethods__["m00"] = _imem_base.IMBLOB_m00_get
    if _newclass:m00 = _swig_property(_imem_base.IMBLOB_m00_get, _imem_base.IMBLOB_m00_set)
    __swig_setmethods__["m10"] = _imem_base.IMBLOB_m10_set
    __swig_getmethods__["m10"] = _imem_base.IMBLOB_m10_get
    if _newclass:m10 = _swig_property(_imem_base.IMBLOB_m10_get, _imem_base.IMBLOB_m10_set)
    __swig_setmethods__["m01"] = _imem_base.IMBLOB_m01_set
    __swig_getmethods__["m01"] = _imem_base.IMBLOB_m01_get
    if _newclass:m01 = _swig_property(_imem_base.IMBLOB_m01_get, _imem_base.IMBLOB_m01_set)
    __swig_setmethods__["minor"] = _imem_base.IMBLOB_minor_set
    __swig_getmethods__["minor"] = _imem_base.IMBLOB_minor_get
    if _newclass:minor = _swig_property(_imem_base.IMBLOB_minor_get, _imem_base.IMBLOB_minor_set)
    __swig_setmethods__["major"] = _imem_base.IMBLOB_major_set
    __swig_getmethods__["major"] = _imem_base.IMBLOB_major_get
    if _newclass:major = _swig_property(_imem_base.IMBLOB_major_get, _imem_base.IMBLOB_major_set)
    __swig_setmethods__["irradiance"] = _imem_base.IMBLOB_irradiance_set
    __swig_getmethods__["irradiance"] = _imem_base.IMBLOB_irradiance_get
    if _newclass:irradiance = _swig_property(_imem_base.IMBLOB_irradiance_get, _imem_base.IMBLOB_irradiance_set)
    __swig_setmethods__["xcg"] = _imem_base.IMBLOB_xcg_set
    __swig_getmethods__["xcg"] = _imem_base.IMBLOB_xcg_get
    if _newclass:xcg = _swig_property(_imem_base.IMBLOB_xcg_get, _imem_base.IMBLOB_xcg_set)
    __swig_setmethods__["ycg"] = _imem_base.IMBLOB_ycg_set
    __swig_getmethods__["ycg"] = _imem_base.IMBLOB_ycg_get
    if _newclass:ycg = _swig_property(_imem_base.IMBLOB_ycg_get, _imem_base.IMBLOB_ycg_set)
    __swig_setmethods__["mu11"] = _imem_base.IMBLOB_mu11_set
    __swig_getmethods__["mu11"] = _imem_base.IMBLOB_mu11_get
    if _newclass:mu11 = _swig_property(_imem_base.IMBLOB_mu11_get, _imem_base.IMBLOB_mu11_set)
    __swig_setmethods__["mu20"] = _imem_base.IMBLOB_mu20_set
    __swig_getmethods__["mu20"] = _imem_base.IMBLOB_mu20_get
    if _newclass:mu20 = _swig_property(_imem_base.IMBLOB_mu20_get, _imem_base.IMBLOB_mu20_set)
    __swig_setmethods__["mu02"] = _imem_base.IMBLOB_mu02_set
    __swig_getmethods__["mu02"] = _imem_base.IMBLOB_mu02_get
    if _newclass:mu02 = _swig_property(_imem_base.IMBLOB_mu02_get, _imem_base.IMBLOB_mu02_set)
    __swig_setmethods__["ratio"] = _imem_base.IMBLOB_ratio_set
    __swig_getmethods__["ratio"] = _imem_base.IMBLOB_ratio_get
    if _newclass:ratio = _swig_property(_imem_base.IMBLOB_ratio_get, _imem_base.IMBLOB_ratio_set)
    __swig_setmethods__["dir"] = _imem_base.IMBLOB_dir_set
    __swig_getmethods__["dir"] = _imem_base.IMBLOB_dir_get
    if _newclass:dir = _swig_property(_imem_base.IMBLOB_dir_get, _imem_base.IMBLOB_dir_set)
    __swig_setmethods__["r"] = _imem_base.IMBLOB_r_set
    __swig_getmethods__["r"] = _imem_base.IMBLOB_r_get
    if _newclass:r = _swig_property(_imem_base.IMBLOB_r_get, _imem_base.IMBLOB_r_set)
    def __init__(self): 
        """
        __init__(IMBLOB self) -> IMBLOB

        C++ includes: miatypes.h

        """
        this = _imem_base.new_IMBLOB()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _imem_base.delete_IMBLOB
    __del__ = lambda self : None;
IMBLOB_swigregister = _imem_base.IMBLOB_swigregister
IMBLOB_swigregister(IMBLOB)

_MIALIB_IMEM_H = _imem_base._MIALIB_IMEM_H

def free_image(*args):
  """
    free_image(IMAGE im)

    free an image and its associated memory used to stored the pixel values  

    Parameters
    ----------
    * `im` :  
        IMAGE pointer  

    Returns
    -------
    void  

    """
  return _imem_base.free_image(*args)

def iminfo(*args):
  """
    iminfo(IMAGE im)

    print in stdout the values of the fields of the given IMAGE  

    Parameters
    ----------
    * `im` :  
        IMAGE pointer  

    Returns
    -------
    void  

    """
  return _imem_base.iminfo(*args)

def create_image(*args):
  """
    create_image(int data_type, long nx, int ny, int nz) -> IMAGE

    create an IMAGE in memory and allocate the memory for the specified number of
    pixels  

    Parameters
    ----------
    * `data_type` :  
        integer for data type  
    * `nx` :  
        long integer for number of columns  
    * `ny` :  
        integer for number of lines  
    * `nz` :  
        integer for number of planes  

    Returns
    -------
    IMAGE pointer on success, NULL otherwise  

    """
  return _imem_base.create_image(*args)

def copy_image(*args):
  """
    copy_image(IMAGE im) -> IMAGE

    generate a physical copy of an IMAGE  

    Parameters
    ----------
    * `im` :  
        IMAGE pointer  

    Returns
    -------
    IMAGE pointer on success, NULL otherwise  

    """
  return _imem_base.copy_image(*args)

def copy_lut(*args):
  """
    copy_lut(IMAGE im1, IMAGE im2) -> ERROR_TYPE

    copy the LUT associated with the first IMAGE to the LUT associated with the
    second IMAGE  

    Parameters
    ----------
    * `im1` :  
        IMAGE pointer  
    * `im2` :  
        IMAGE pointer  

    Returns
    -------
    NO_ERROR on success, ERROR otherwise  

    """
  return _imem_base.copy_lut(*args)

def create_lut(*args):
  """
    create_lut(IMAGE im) -> ERROR_TYPE

    create a LUT and associate it with the input IMAGE. A LUT consists of 768 values
    indicating the RGB value of any byte pixel value (the codes are interleaved by
    band in the RGB order).  

    Parameters
    ----------
    * `im` :  
        IMAGE pointer  

    Returns
    -------
    NO_ERROR on success, ERROR otherwise  

    """
  return _imem_base.create_lut(*args)

def free_lut(*args):
  """
    free_lut(IMAGE im)

    free the LUT associated with an IMAGE  

    Parameters
    ----------
    * `im` :  
        IMAGE pointer  

    """
  return _imem_base.free_lut(*args)

def imtoarray(*args):
  """
    imtoarray(IMAGE im, IMAGE imroi) -> IMAGE

    """
  return _imem_base.imtoarray(*args)

def arraytoim(*args):
  """
    arraytoim(IMAGE im, IMAGE imroi) -> IMAGE

    """
  return _imem_base.arraytoim(*args)

def setpixval(*args):
  """
    setpixval(IMAGE im, unsigned long offset, G_TYPE g) -> ERROR_TYPE

    set the pixel value of im at position offset to the value encapsulated in g  

    Parameters
    ----------
    * `im` :  
        IMAGE pointer  
    * `offset` :  
        int for offset from origin (0 for 1st pixel)  
    * `g` :  
        G_TYPE for pixel value  

    Returns
    -------
    NO_ERROR on success, ERROR otherwise  

    """
  return _imem_base.setpixval(*args)

def getpixval(*args):
  """
    getpixval(IMAGE im, unsigned long offset) -> G_TYPE

    get the pixel value of im at position offset  

    Parameters
    ----------
    * `im` :  
        IMAGE pointer  
    * `offset` :  
        int for offset from origin (0 for 1st pixel)  

    Returns
    -------
    G_TYPE for pixel value  

    """
  return _imem_base.getpixval(*args)

def GetImBitPerPixel(*args):
  """
    GetImBitPerPixel(IMAGE im) -> int

    returns the number of bits used to store an individual pixel, -1 on failure.  

    Parameters
    ----------
    * `im` :  
        IMAGE pointer  

    Returns
    -------
    integer holding number of bits used to store a pixel, -1 on failure  

    """
  return _imem_base.GetImBitPerPixel(*args)

def create_imarray(*args):
  """
    create_imarray(int arg1) -> IMAGE **

    create a pointer to an IMAGE array with n elements  

    Parameters
    ----------
    * `n` :  
        int for number of elements  

    Returns
    -------
    IMAGE * pointer  

    """
  return _imem_base.create_imarray(*args)

def shmatimage(*args):
  """
    shmatimage(key_t shmkey, size_t nx, size_t ny, size_t nz, size_t nbyte, int type) -> IMAGE

    """
  return _imem_base.shmatimage(*args)

def shmdtimage(*args):
  """
    shmdtimage(void * shm_address, int semkey_flag, key_t semkey) -> ERROR_TYPE

    """
  return _imem_base.shmdtimage(*args)
# This file is compatible with both classic and new-style classes.


