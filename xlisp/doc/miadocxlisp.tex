\documentclass{book}
\usepackage{makeidx}
\usepackage[utf8]{inputenc} 
%PS from Jacopo
\def\mypar#1{{\mbox{\texttt{\large{\lowercase{#1}}}}}}
\def\myform#1{\ensuremath{\displaystyle #1}}
%ENPS

%% \newif\ifpdf
%% \ifx\pdfoutput\undefined
%% \pdffalse
%% \else
%% \pdfoutput=0  % should be one but then no dvi produced
%% \pdftrue
%% \fi

%\ifpdf
%\usepackage[breaklinks=true,
%pdftex,
%bookmarks=true]{hyperref}
%\else
%\usepackage[latex2html,dvips]{hyperref}
\usepackage[breaklinks=true]{hyperref}
%\fi
\usepackage{url}
%\usepackage{html}

%\usepackage{rotating}
\usepackage{natbib}
\usepackage{times}
\usepackage{makeidx}
\usepackage{natbib}
\usepackage{threeparttable}
\usepackage{ifpdf}

%\providecommand{\doi}[1]{\href{http://dx.doi.org/#1}{doi:#1}}


\def\l{english}
\def\english{english}
\input{mmacro}
\renewcommand{\SE}{{SE}}

\newcommand{\crtlspfile}{UNDEFINED FILE NAME}

\input{cfit}
\input{cfet}
\input{cfvt}

\newcommand{\imsekey}{\mbox{\tt imse}}
\newcommand{\oxkey}{\mbox{\tt ox}}
\newcommand{\oykey}{\mbox{\tt oy}}
\newcommand{\ozkey}{\mbox{\tt oz}}
\newcommand{\rankkey}{\mbox{\tt rank}}
\newcommand{\reflectkey}{\mbox{\tt reflect}}
\newcommand{\dxkey}{\mbox{\tt dx}}
\newcommand{\dykey}{\mbox{\tt dy}}
\newcommand{\originkey}{\mbox{\tt origin}}
\newcommand{\tikey}{\mbox{\tt ti}}
\newcommand{\indexkey}{\mbox{\tt index}}
\newcommand{\periodkey}{\mbox{\tt period}}
\newcommand{\graphkey}{\mbox{\tt graph}}
\newcommand{\cardnkey}{\mbox{\tt cardn}}
\newcommand{\roikey}{\mbox{\tt roi}}

\newcommand{\optk}{(x)}
\newcommand{\reqk}{x}

\newcommand{\maxNumberOfBands}{255}

\bibliographystyle{plainnat}

\setlength{\parindent}{0cm}

%\newcommand{\capitolo}[1]{\chapter{#1}}

\newcommand{\module}[1]{\chapter{#1}}


%PROBLEM-WITH-LABEL \newcommand{\lspfunction}[3]{\subsection{(#1#2 #3)}\label{#1#2}\index{#2@\texttt{"#1}#2}}
%\newcommand{\lspfunction}[3]{\subsection{(#1#2 #3)}} %\index{#2@\texttt{"#1}#2}}

\newcommand{\lspfunction}[3]{\subsection{(#1#2 #3)}\index{#2}}

\newcommand{\basesection}{\section{Base functions}}
\newcommand{\lispsection}{\section{Lisp functions}}
\newcommand{\text}[1]{#1}

\newcommand{\param}[2]{{\bf #1}: #2

}

\newcommand{\key}[2]{{\bf #1}: #2

}

\newcommand{\return}[1]{RETURNS: #1

}

\newcommand{\cfunction}[1]{C FUNCTION: #1

}
\newcommand{\cfile}[1]{C FILE: \htmladdnormallink{#1}{file:../../core/c/#1}

}
\newcommand{\xlispcfile}[1]{C FILE: \htmladdnormallink{#1}{file:../c/#1}

}

\newcommand{\lspfile}[1]{LSP FILE: \htmladdnormallink{#1}{file:../lsp/#1}

}
\newcommand{\coding}[1]{Coding note: #1}

%\renewcommand{\cfunction}[1]{}
%\renewcommand{\cfile}[1]{}
%\renewcommand{\xlispcfile}[1]{}

\newcommand{\example}[2]{EXAMPLE: #1 #2

}

\newcommand{\desc}[1]{DESCRIPTION: #1

}

\newcommand{\myseealso}[1]{SEE ALSO: #1

}
\newcommand{\feature}[1]{FEATURE: #1

}
\newcommand{\authors}[1]{Author(s): #1

}
\newcommand{\creationdate}[1]{Creation date: #1

}
\newcommand{\changedate}[1]{Change date: #1

}
\newcommand{\history}[1]{History log: #1

}


\newcommand{\descox}{integer for x coordinate of origin of SE}
\newcommand{\descoy}{integer for y coordinate of origin of SE}
\newcommand{\descoz}{integer for z coordinate of origin of SE}
\newcommand{\descoxdef}{integer for x coordinate of origin of SE (default set to integer part of half the width of the SE)}
\newcommand{\descoydef}{integer for y coordinate of origin of SE (default set to integer part of half the width of the SE)}
\newcommand{\descozdef}{integer for z coordinate of origin of SE (default set to integer part of half the number of x-y planes of the SE)}

\newcommand{\lspsubfunction}[3]{\subsubsection{(\texttt{#1#2 #3})}\label{func:#1#2}\index{#2@\texttt{"#1}#2}}


%\newcommand{\sref}[1]{\htmlref{#1}{#1}}

\newcommand{\sref}[1]{\href{#1}{#1}}

%% ; To force name consistency use \starsetpix and not *setpix.
%% ; Note that there should be no need to link to non-destructive
%% ; versions of destructive functions.
%% ; All new commands should be parsed to
%% ; mialisp to check their existence.
\newcommand{\setpix}{*setpix}

\newcommand{\atcmp}{@cmp}
\newcommand{\atoverlay}{@overlay}
\newcommand{\atthresh}{@thresh}
\newcommand{\atsub}{@sub}

\newcommand{\starcrgbtorgb}{*crgb2rgb}
\newcommand{\stargetpixmax}{*getpixmax}

\def\mypar#1{{\mbox{\texttt{\lowercase{#1}}}}}
\def\myfunc#1{\texttt{\lowercase{#1}}}


\makeindex


\renewcommand{\htmladdnormallink}[2]{\href{#2}{#1}}

\begin{document}

\pagenumbering{roman}

\title{MIALisP\\Morphological Image Analysis through LisP}
\author{\htmladdnormallink{Pierre Soille}{mailto:Pierre.Soille@jrc.ec.europa.eut?subject=MIALisP}\\
\htmladdnormallink{Joint Research Centre of the European Commission}{http://www.jrc.ec.europa.eu}}


\setcounter{tocdepth}{2}


\maketitle

%\begin{latexonly}

\cleardoublepage
\addcontentsline{toc}{chapter}{Table of Contents}
\tableofcontents
%\end{latexonly}

\newpage
\pagenumbering{arabic}

\chapter{Installation notes}
mialisp consists of a combination of low level Morphological Image Analysis (MIA) routines written in ANSI C and a LisP interpreter called XLISP-PLUS and written by Thomas Almy and others.  The latter follows closely ANSI Common LisP.  Detailed information on XLISP-PLUS can be found on \htmladdnormallink{http://www.almy.us/xlisp.html}{http://www.almy.us/xlisp.html}.  Tutorials and many additional resources on LisP can be found on \htmladdnormallink{http://www.lisp.org}{http://www.lisp.org}.  In any case, you (the user) should not be afraid by the LisP language because its syntax is simple and concise.  In addition, you need to know very few LisP idioms to start using mialisp for real applications.  Just have a look at some examples!


The archive file mialisp.zip should contain all you need to run mialisp on Windows/Linux platforms.  The archive is organised into 6 subdirectories named bin, lsp, doc, images, lib, and include:
\begin{itemize}
\item {\bf bin} contains executables for Linux (see mialisp or xliiar) and Windows (see mialisp.exe).
\item {\bf lsp} contains lisp files defining numerous new lisp functions for processing your images.  Among these files, the file \htmladdnormallink{init.lsp}{../lsp/init.lsp} defines path variables and load all the other lisp files.  Please look through the path variables to make sure they match your local installation.  In the definition of paths, note that syntactically valid paths must terminate with is a slash '/', e.g., "/home/pierre/mialisp/lsp/" is valid but not "/home/pierre/mialisp/lsp".
\item {\bf doc} contains the present document in html and pdf formats (see \htmladdnormallink{miadoc.html}{miadoc.html} and  \htmladdnormallink{miadoc.pdf}{miadoc.pdf}).  For convenience, I have also included a copy of the XLISP-PLUS reference manual written by Thomas Almy (see \htmladdnormallink{xlispdoc.pdf}{xlispdoc.pdf}).
\item {\bf images} contains a series of images used by mialisp.
\item {\bf lib} contains libraries such as libtiff.dll, the \htmladdnormallink{libtiff}{http://www.libtiff.org} DLL necessary to run mialisp on Windows platforms.  For users interested in linking the C routines to another environment than that provided by XLISP-PLUS, I have also included the static library containing all morphological image analysis routines without any reference to XLISP-PLUS functionalities.  It is called mialib.a under Lin*x and mialib.lib under Windows.  By writing appropriate wrapper functions, it should be possible to make the functionalities of the mia library to other environments such as IDL or MatLab.
\item {\bf include} contains header files necessary for extending the functionalities of the C library or link it to another environment.  The key header file is named liiar.h: it contains, among many other things, the image structure definition as well as a set of 'get' and 'set' macros to get/set the values of its fields.
\end{itemize}

For displaying images, I recommend the excellent free image viewer 'imview' written by Hugues Talbot.  You can download and install the latest version from \htmladdnormallink{\url{http://www.cmis.csiro.au/Hugues.Talbot/imview/}}{http://www.cmis.csiro.au/Hugues.Talbot/imview/}.  For data plotting, gnuplot is certainly a first-class choice, see details at \htmladdnormallink{\url{http://www.gnuplot.info/}}{http://www.gnuplot.info/}.  GSview (or simply the command gv under Un*x) can be used to visualise postscript files, see details at \htmladdnormallink{\url{http://www.cs.wisc.edu/~ghost/gsview/get46.htm}}{http://www.cs.wisc.edu/~ghost/gsview/get46.htm}.  Finally, for editing lisp files, the GNU-emacs editor due to Richard Stallman is surely the most powerful (incidentally, it is itself based on Lisp!).  This editor is included in most Linux distributions.  Windows users can download it from \htmladdnormallink{\url{http://ftp.gnu.org/pub/gnu/emacs/windows/}}{http://www.gnu.org/software/emacs/windows/ntemacs.html}.



\chapter{Introduction}

\section{Getting started: a simple example}
Once you have launched mialisp, make sure that the file \htmladdnormallink{init.lsp}{../lsp/init.lsp} file has been loaded.  If it has not been automatically loaded, you can load it (as well as any other lsp file you may want to load) with the load command by typing (load "../lsp/init").  Of course, you may need to adjust the path to your local configuration.

Assume you want to fill in all holes (regional minima) of a digital elevation model.  You need first to call the function *readimage giving a string containing the name (and path if it does not reside in the working directory) of the input image.  The *readimage function assumes that the input image is in TIFF format.  Therefore the command you need to type in should look like (\htmlref{*readimage}{*readimage} "mydem.tif").  This command, like any other lisp command, returns a value.  Also, note that every LisP command is enclosed by parenthesis (some have coined LisP as meaning Lots of Insipid Stupid Parentheses).  On failure, *readimage returns NIL, otherwise it returns an image node containing the image you wanted to read.  The question is, how do I access this image node?  A solution is to bind this image node to a variable name.  This can be achieved by the LisP function setq\footnote{The lisp function setq is used for assigning a value to a variable, for example (setq x 5) assigns the value 5 to the variable x.  'setq' is a contraction for 'set quote' because (setq x 5) is equivalent to the lower level call (set (quote x) 5) or, equivalently, (set 'x 5).  Indeed, the function quote returns its argument as such, i.e., without evaluating it.}.  In this latter case, you need to type something like (setq dem (*readimage "mydem.tif")).  From now on, you can use dem as an input to other functions requiring an image node as input argument.  For example, (\htmlref{*iminfo}{*iminfo} dem) prints on your screen the information about the image stored in the corresponding C image data structure.  To view an image read by mialisp, you need to have an external image viewer such as imview (see installation notes).  Provided that the path to this viewer is known or has been correctly specified in the file  \htmladdnormallink{init.lsp}{../lsp/init.lsp}, you can view your image using the command (\htmlref{*imview}{*imview} 'dem).  Beware that you need to quote the image variable name for all viewing functions.  There is a more general viewing function named *displaycmd whereby you need to specify the name of the viewer (possibly including its path) you want to use.  For example, (\htmlref{*displaycmd}{*displaycmd} 'dem "gimp") will display the image dem with \htmladdnormallink{gimp}{gimp}.

Remember that the goal of this example was to fill in all holes of the input digital elevation model.  There is a function called *fillhole for this purpose (see index of documentation).  It requires 2 arguments, the first must be an image node and the second defines the connectivity you want to use (either 4 or 8).  Therefore, you need to type either (\htmlref{*fillhole}{*fillhole} dem 4) or (\htmlref{*fillhole}{*fillhole} dem 8) to fill in the holes of dem.  If you want to name the output, simply type (setq demfill (*fillhole dem 4)).  Finally, you may need to save your result on disk.  Use the function *writetiff for this purpose: (\htmlref{*writetiff}{*writetiff} demfill "dem-fill4.tif").  In summary, after keying all the previous commands, a snapshot of your window running mialisp should look like:
\begin{verbatim}
> (setq qq (*readimage "../thyle.tif"))
#<Image: #8183608>
> (*imview 'qq)
T
> (setq ww (*fillhole qq 4))
#<Image: #818308c>
> (*writetiff ww "/tmp/thyle-fill4.tif")
T
> 
\end{verbatim}
Note that the two images referred to by the qq and ww nodes are held in memory.  If necessary, they can be freed by calling the *imfree function: ( \htmlref{*imfree}{*imfree} qq ww).  Rather than naming the ouput nodes of each individual function, you could have achieved the same result by typing the following command (note that well positioned linebreaks can significantly improve the readability of your code):
\begin{verbatim}
(*writetiff
  (*fillhole
    (*readimage "../thyle.tif")
    4)
  "/tmp/thyle-fill4.tif")
\end{verbatim}
Hence, the output of the *readimage function defines the first argument of the *fillhole function while the output of the *fillhole function defines the image node required by the *writetiff function.  In this latter example, the two intermediate images created by *readimage and *fillhole are automatically freed (by the so called garbage collector of LisP) as soon as they are not required.  Indeed, because they have not been named, there is no reference to them.  Finally, in case you need to define a new function performing this task, you can use the LisP function defun to build it (and preferably write this new definition in a local lisp file which you can then load later on with the load function):
\begin{verbatim}
(defun fillondisk (infn outfn graph)
  ; infn:  string for input filename
  ; outfn: string for output filename
  ; graph: integer for connectivity (either 4 or 8)
  (*writetiff
    (*fillhole
      (*readimage infn)
      graph)
  outfn)
)
\end{verbatim}
This example also illustrates that all what you write afer the `;' is considered as a comment and is therefore not interpreted.  If you wrote the definition of this new function in a file (say local.lsp), you need to type (load "local") to make mialisp aware of this new function.  You can then simply type (fillondisk "dem.tif" "dem-fill4.tif" 4) to achieve the same effect as the series of commands detailed before.  To exit mialisp, type (exit).  That's it.

Exercise: generate an image indicating the set of pixels modified by *fillhole (1 if modified, 0 otherwise).  Hint: possible solution based on \sref{\atsub}, \sref{\atthresh}, and \sref{\stargetpixmax}.  More direct solution based on \sref{\atcmp}.

%PS Highlight these pixels on the input image by setting them to a specific colour.  
%PS for the first part, and \sref{\starcrgbtorgb} for the second part
%PS (setq overlay (*crgb2rgb dem dem mask))
%PS (*xv 'overlay) ; view highlighted image (2nd part)

A solution:
\begin{verbatim}
(setq dem (*readimage "dem.tif"))
(setq mask
      (@thresh
       (@sub (*fillhole dem 4) dem)
      1 (*getpixmax dem) 0 1)
      )
(*imview 'mask)
\end{verbatim}

%PS (to overlay the mask on the input dem, we use the function  \sref{\atoverlay})

\section{Destructive versus non-destructive definitions}
Most lisp functions are non-destructive in the sense that they do not modify their input arguments.  However, because images require a lot of memory, many image processing functions of mialisp have a destructive variant whereby the first input image, given as an argument, is overwritten by the output.  Destructive functions always start with the @ sign while non-destructive functions start with the * sign.  Contrary to what happens with non-destructive functions, all destructive functions (i.e. functions starting with the @ sign) have a non-destructive equivalent.
The non-destructive equivalent of a destructive function is simply obtained by substituting the @ sign by the * sign.  For example,  (\htmlref{@add}{@add} im1 im2) performs the point-wise addition of the images im1 and im2, overwrites the result im im1 and returns im1 while (*add im1 im2) performs the same operation but do not overwrites im1 since a new image node containing the result of the addition is returned.  In the documentation, specific entries for the non-destructive version of destructive functions have been omitted (by definition, there exists a non-destructive version of every destructive function).

\section{Base versus lisp definitions}
Documented functions are organised in chapters roughly following those of \citep{soille99,soille2004sv}.  Each chapter is divided in {\em base\/} and {\em lisp\/} functions.  Base functions are functions that have a direct C routine counterpart.  Lisp functions are defined in lisp and may call several base functions.  Indeed, it makes little sense to define a C function for defining an operation such as an opening by a given {\SE}: a better approach is to define in lisp an opening function which first call the erosion by this {\SE} and then the dilation by the reflected {\SE} (see file  \htmladdnormallink{opclo.lsp}{../lsp/opclo.lsp} for further examples):
\begin{verbatim}
(defun *open (im imse)
  (*dilate (*erode im imse) imse 1)
  )
\end{verbatim}
In this example, the reflection of the {\SE} is indicated by setting to 1 the optional (third) parameter of the *dilate function.  Similarly, the non-destructive version of a destructive function is simply defined in LisP thanks to the \htmlref{*imcopy}{*imcopy} function which returns a copy of the input image (image duplication).  For example, the non-destructive version of the \htmlref{@sqrt}{@sqrt} function, which replaces the value of each pixel of the input image by its square root, is defined as follows:
\begin{verbatim}
(defun *sqrt (im)
  (@sqrt (*imcopy im))
  )
\end{verbatim}

Base functions (i.e., functions written in C) may be considered as the alphabet of mialisp.  Words are defined as new lisp functions consisting of as a sequence of calls to base functions.  Available words are defined in the accompanying lisp files.  Solving an image analysis problems consists in writing meaningful sentences based on these words. This is a challenging task requiring expertise acquired through training.  An important goal of mialisp is to provide newcomers with a means to learn how to develop a solution by practicing theoretical notions on real image analysis problems.

%PS  In addition, man psome solutions may require the expansion of the morphological vocabulary by defining new words useful to some other applications.



\section{Parameter definition}\label{s.pd}

NOTICE: the general guidelines described in the present section are quite general and allow for the definition of a single function to perform a variety of specific operations.  For example, they allow for the definition of a general *erosion function requiring the definition of {\SE} type, size, reflection flag, optional additional parameters such as slope when considering line segment {\SE}s, etc.  Depending on the type of {\SE}, \htmlref{*erosion}{*erosion} will automatically call the most efficient implementation and/or decomposition strategy.  This type of general function lives together with a variety of specific functions such as \htmlref{@linero}{@linero} for erosion by a line segment of given length and orientation.

~\\

Most morphological operations require an input image and a structuring element of given size.  Several structuring element types are allowed for depending on the considered operation (an error message will appear in case the chosen type is not possible or not implemented for the chosen operation).  The list of all possible types as well as the meaning of their size parameter and possible optional keys are described hereafter and summarised in table~\ref{t.sekeys}:
\begin{itemize}

\item 'flat: arbitrary flat structuring element defined by an image node given by the required key parameter {\imsekey}.  The size parameter is a positive integer value indicating how many times the {\SE} must be dilated by its reflection so as to generate a larger {\SE}.  In the case of erosions and dilations, this comes down to indicate how many times the considered operation must be iterated.  A size different from 1 should be used with caution when considering non convex {\SE}s.  The following keys are valid:

\begin{itemize}
\item {\imsekey} (required): an image node.  It must be an unsigned char image whereby pixels belonging to the {\SE} are those with a value different from zero.  
\item \oxkey, \oykey, \ozkey: integer values for specifying the origin of the {\SE}.  By default,  (\oxkey, \oykey, \ozkey) is defined as the integer part of half its width, height, and number of x-y planes.
\item \rankkey: integer value indicating the rank when considering rank filters. It must be in the interval $[1,\card{\imsekey}]$.
\item \reflectkey:  value 0 or 1 indicating whether the {\SE} must be reflected or not.  Value 0 for no reflection (default), value 1 for reflection.
\end{itemize}


\item 'line: line segment whose length in number of pixels if given by the size parameter.  The slope of the line segment is expressed in terms of a rationale number  given by $\dykey/\dxkey$ including the degenerated forms 0/1 and 1/0 specifying vertical and horizontal line segments.  The following keys are valid:

\begin{itemize}
\item \dxkey, {\dykey} (required): integer values for specifying slope, the slope angle being equal to $\arctan(\dykey/\dxkey)$.
\item \originkey: integer value in the range $[0,size-1]$ for specifying the origin of the line segment.  By default, it is taken as the integer part of size/2.
\item \periodkey: integer value for indicating the 
\item \rankkey:  integer value indicating the rank when considering rank filters. It must be in the interval $[1,size]$.
\item \tikey:  value 0 or 1 indicating whether a translation-variant or invariant algorithm must be considered.  Value 0 for translation-variant (default), value 1 for translation-invariant.
\item \reflectkey:  value 0 or 1 indicating whether the line segment must be reflected or not.  Value 0 for no reflection (default), value 1 for reflection.
\end{itemize}

\item 'square: square-shaped {\SE}.  The size parameter indicated the width this square in number of pixels.  The implementation is based on the decomposition presented in \citep{soille2004sv} on page 81,  Eq.~3.12.  The following keys are valid:  
\begin{itemize}
\item \oxkey, \oykey: integer values for specifying the origin of the {\SE} when considering a rank filter.  By default,  (\oxkey, \oykey) is defined as the integer part of half its width, and height.
\item \reflectkey:  value 0 or 1 indicating whether the {\SE} must be reflected or not.  Value 0 for no reflection (default), value 1 for reflection.
\end{itemize}

\item 'diamond: diamond-shaped {\SE}, i.e., square on its tip.  The size parameter indicated the width this square in number of pixels.  The implementation is based on the decomposition presented in \citep{soille2004sv} on page 81,  Eq.~3.13.  No reflection key is required because the centre of diamond-shaped {\SE}s always match the centre of a pixel.

\item 'octagon: octagon-shaped {\SE}, its width being proportional to the size parameter.   The implementation is based on the decomposition presented in \citep{soille2004sv} on page 81.

\item 'octagonprime: another octagon-shaped {\SE}, its width being proportional to the size parameter.   The implementation is based on the decomposition presented in \citep{soille2004sv} on page 81.

\item 'area: connected structuring element whose number of pixels is given by the size parameter.  The following keys are valid:  
\begin{itemize}
\item {\graphkey} (required): integer value for indicating the connectivity (either 4 or 8).
\item \roikey: not yet available
\end{itemize}


\item 'parametric: structuring element whose number of pixels is given by the key {\cardnkey} and that must be included in the structuring element specified by the key \imsekey.  The following keys are valid:
\begin{itemize}
\item {\imsekey} (required): an image node.  It must be an unsigned char image whereby pixels belonging to the {\SE} are those with a value different from zero.
\item {\cardnkey} (required): a positive integer value indicating the number of pixels of the subsets of the {\SE} defined by the key \imsekey.
\end{itemize}

\end{itemize}



\begin{threeparttable}
%\begin{table}
\centering
\caption{\label{t.sekeys}Structuring element types, the meaning of their size paramenter, and their required/optional keys.  The area and parametric {\se} types are reserved for opening and closing operations.}
\begin{tabular}{lllp{4.25cm}}
\noalign{\smallskip}\hline\noalign{\smallskip}
{\se} type  & size             & required keys              &  optional keys \\
\noalign{\smallskip}\hline\noalign{\smallskip}

'flat        & number\tnote{a}  & \imsekey                   &  \oxkey, \oykey, \ozkey, \rankkey, \reflectkey                    \\
%PS 'grey        & number\tnote{a}  & \imsekey                   &  \oxkey, \oykey, \ozkey, \rankkey, \reflectkey                    \\
%PS 'composite   & number\tnote{a}  & \imsekey                   &  \oxkey, \oykey, \ozkey, \rankkey, \reflectkey                    \\
'line        & length           & \dxkey, \dykey             &  \originkey, \periodkey, \rankkey, \tikey, \reflectkey \\
'diamond     & width            &                            &  \reflectkey                                                      \\
'square      & width            &                            &  \oxkey, \oykey, \rankkey                                         \\
'octagon     & width            &                            &                                                                   \\
'octagonprime& width            &                            &                                                                   \\
'area        & card. number     & \graphkey                  &  \roikey                                                          \\
'parametric  & must be 1        & \imsekey, \cardnkey\tnote{b}&                                                                   \\
\noalign{\smallskip}\hline

\end{tabular}
\begin{tablenotes}
\scriptsize
\item[a] \scriptsize in the sense of ${n\seb}=\dilate^{(n-1)}_{\transpose{\seb}}(\seb)$ where $\seb$ refers to {\imsekey} and $n$ to number.
\item[b] \scriptsize card denotes the cardinal number of the subset of {\imsekey} if given as an integer value or, alternatively, as a percentage of pixels of {\imsekey} if given as floating point value.
%PS \item[c] \scriptsize .
\end{tablenotes}
\end{threeparttable}
%\end{table}

% \multicolumn{4}{l}{1. Erosions, dilations, and rank filters} \\
% \multicolumn{4}{l}{2. Openings and closings} \\



\section{Image model}
Monochannel images defined over the square or cubic grids are dealt with\footnote{Note however that multichannel 2-D images such as colour RGB images are successfully but these images are handled as if they were 3-D images, i.e., one 2-D x-y plane per channel.  Each plane can then be extracted for creating a series of monochannel 2-D images, see I/O chapter (Chap.~\ref{m.io}) for more details.}.  At the C level of the library, all information pertaining to an image is accessed through an image data structure defined as follows:

\begin{verbatim}
typedef struct image {
  char *p_im;    /* Pointer to image data */
  int DataType;  /* Image data type */
  int nx;        /* Number of columns */
  int ny;        /* Number of lines */
  int nz;        /* Number of x-y planes */
  ULGINT NByte;  /* Number of bytes for image data */
  VOL_TYPE vol;  /* Sum of pixel values (volume) */
  USHORT *lut;   /* Pointer to colour map */
} IMAGE; 
\end{verbatim}

The physical dimensions of the image is defined by 3 fields: nx (or number of image columns), ny (or number of image lines), and nz (or number of x-y planes).  For monochannel 2-dimensional (2-D) images, nz equals 1.  For monochannel 1-D profiles, both ny and nz equal 1.  The third dimension is used either to store the successive channels of multichannel 2-D images or the successive x-y planes of 3-D monochannel images.  In the former case, nz represents the number of available bands while in the latter, it denotes the number of available x-y planes.  Note however that the image structure does not contain a field for specifying whether an image with more than 1 x-y plane is a multichannel 2-D or a monochannel 3-D image.  By default, existing routines consider it as a monochannel 3-D image.  Indeed, routines processing multichannel images require to pass on a series of monochannel images as argument, one per channel.  A specific band can be extracted from a multichannel image by using the function \htmlref{*getxyplane}{*getxyplane}.

In the current version of mialisp many operations are implemented solely for 2-D monochannel images.  A noticeable exception concerns all point image transformations since their implementation does not depend on the number of image dimensions, each band being treated independently in the case of multichannel images.

The actual pixel values are stored in a 1-D array referred to by the generic pointer *p\_im.  The image origin of a 2-D image is defined by its upper left pixel.  That is, the upper left pixel is at coordinates (0,0,0) while the lower right pixel is at coordinates (nx-1,ny-1,0) where nx (resp. ny) denotes the number of image columns (resp. lines).  Pixels are stored in the 1-D array in the lexicographical order, from the 1st to the nzth plane.  That is, the pixel at coordinates (x,y,z) of a 3-D image lies at the index position x+ny*y+(nx*ny)*z in the 1-D array.  At the interpreter level, there exists a series of functions to retrieve or modify the pixel values occurring at a given coordinate or index value, see Chap.~\ref{m.memlut}.

For example, (\htmlref{*setpix}{*setpix} im x y z val) sets to val the pixel of the image im at coordinates (x,y,z), see \ref{*setpix}.  An equivalent effect is obtained by calling (\htmlref{*setpixi}{*setpixi} im i val) where the index value i equals x+ny*y+(nx*ny)*z.  The value of nx can be obtained thanks to a call to (\htmlref{*getnx}{*getnx} im).  Analog functions are defined for \htmlref{ny}{*getny} and  \htmlref{nz}{*getnz}, see Chap.~\ref{m.memlut}.

The data type of the pixel values is defined by the field DataType.  Authorised data types are uint8\_t (UCHAR), uint16\_t (USHORT), int32\_t (LGINT), float, and double (where the first naming follows the specifications of the stdint.h C header file: u stands for unsigned, int for integer, and the number refers to the number of bits required to store a pixel).  Many functions are defined for a restricted number of data types although most functions are defined for the UCHAR, USHORT, and to a lesser extent LGINT types.  A series of type conversion functions are available at the interpreter level, see Chap.~\ref{m.format}.  For example, (\htmlref{*touchar}{*touchar} im) returns a new image holding the conversion of (the pixels of) im to the UCHAR data type.



\chapter{Background notions}

This chapter can be considered as a companion of the `Background' chapter of \citep{soille2004sv}.


\chapter{Available functions}

\input{xlglue1}


\flushbottom

\cleardoublepage

\addcontentsline{toc}{chapter}{Bibliography}
%\bibliography{strurl,pierre,dem,soille,techrep,proj,cloud,remsens,registration,calib}
\bibliography{miadocxlisp}

\cleardoublepage
\addcontentsline{toc}{chapter}{Index}
\printindex

\end{document}




export BIBINPUTS=$BIBINPUTS:/mnt/workstation/workstation/bib/
bibtool -x miadocxlisp.aux -r /home/soillpi/workstation/bib/clean4mmd.rsc  > miadocxlisp.bib
